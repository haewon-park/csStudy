# Array & ArrayList & LinkedList
## 1. Array
### Array란?
> 배열은 가장 기본적인 데이터 구조
> 배열은 생성시 설정된 셀의 수가 고정되고, 각 셀에는 인덱스 번호가 부여

**시간 복잡도**
|         | Array |
|---------| -------------------- |
| 접근     | O(1) |
| 삽입과 삭제     |O(N) | 

<br>

### 장단점
**장점**
-   바로 만들어서 활용하기가 쉬움
-   더 복잡한 자료 구조의 기초가 될 수 있음
-   원하는 데이터를 효율적으로 탐색/가져올 수 있음 
⇒ ? `Random Access`를 지원하기 때문! 인덱스 번호를 통해 데이터에 바로 접근 가능!
-   정렬에 용이

**단점**
-   데이터를 저장 할 수 있는 메모리 크기가 고정되어 있음
-   데이터 추가 / 삭제 방법이 비효율적
-   구조 재구성 시 정렬하는 방식이 비효율적

**사용**
-   엑셀의 스프레드시트 처럼 직사각형 테이블, 수학적 벡터 (vector) 및 행렬 (matrix)를 구현하는 데 사용
-   다른 데이터 구조에서 사용


<br>

## 2. ArrayList
### ArrayList란?
> 배열을 이용해서 리스트를 구현한 것.

**시간 복잡도**
|         | ArrayList |
|---------| -------------------- |
| 접근     | O(1) |
| 삽입과 삭제(시작)     |O(N) | 
| 삽입과 삭제(끝)     |O(1) | 

<br>

### 장단점
**장점**
-   내부적으로 배열을 이용하기 때문에 인덱스를 이용하여 접근하는 것이 빠름

**단점**
-   데이터의 추가/삭제가 느림

<br>

## 3. LinkedList
### LinkedList란?
> 메모리에 있는 데이터의 물리적 배치를 사용하지 않는 데이터 구조

* Index나 위치보다 **참조 시스템**을 사용 
* 각 요소는 **노드**라는 것에 저장되는데, **다음 노드**  **연결**에 대한 포인터 또는 주소가 포함된 또 다른 노드에 저장
`단일 연결 리스트(Singly-Linked List)`, `이중 연결 리스트(Doubly-Linked List)`, `등등등`

**시간 복잡도**
|         | LinkedList |
|---------| -------------------- |
| 접근     | O(N) |
| 삽입과 삭제     |O(1) | 

<br>

### 장단점
**장점**
-   새로운 요소들의 추가 및 삭제가 용이하고 효율적
-   배열처럼 메모리에 연속적으로 위치하지 않음
-   배열처럼 구조의 재구성이 필요없음
-   동적인 메모리 크기
-   메모리를 더 효율적으로 쓸 수 있기 때문에 대용량 데이터 처리 적합

**단점**
-   배열보다 메모리를 더 사용
-   처음부터 끝까지 순회하기 때문에 원하는 값을 비효율적으로 검색/접근
-   노드를 반대 방향으로 검색할 때 비효율적 (이중 연결 리스트의 경우)

**사용**
-   메모리 크기가 정해져 있지 않을 때
-   데이터를 연속적으로 빠르게 삽입/제거가 필요 할 때
-   이미지 뷰어, 갤러리
-   음악 플레이어

<br>

## 4. 추가 질문
### Array vs LinkedList
|         | Array | LinkedList |
|---------| -------------------- | --------------- |
| 접근     | - **Random Access**<br>- index를 통해 직접 접근<br>- 시간복잡도 O(1) | - **Sequential Access**<br>- 순차적으로 검색하며 접근<br>- 시간복잡도 O(N) | 
| 삽입과 삭제     | - 인접한 메모리 위치에 연이어 저장<br>- 시간복잡도 O(N) | - 새로운 요소에 할당된 메모리 위치 주소가<br>LinkedList의 이전 요소에 저장<br>- 시간복잡도 O(1) | 
| 크기     | - 크기 고정 | - 크기 동적| 
<br>

### Array vs ArrayList
|         | Array | ArrayList |
|---------| -------------------- | --------------- |
| 사이즈    | - **초기화 시 고정** | - **초기화 시 사이즈를 표시하지 않음. 사이즈가 동적** <br>⇒ But, 내부적으로는 배열로 구성되어 있음.| 
| 속도    | - 초기화 시 메모리에 할당되어 속도 빠름 | - 추가 시 메모리를 재할당하여 속도가 느림| 
| 변경    | - 사이즈 변경 불가 | - 추가 삭제 가능| 
| 다차원    | - 가능 | - 불가능| 
| 타입    | - primitive type(int, byte, char etc), object | - object element만 가능| 
| generic    | - 사용 불가능 | - 사용 가능(타입 안정성 보장)| 
| 길이    | - length 변수| - size() 메서드| 
| 변수추가    | - assignment 연산자 사용 | - add() 메소드 사용| 


<br>

###  ArrayList vs LinkedList
|         | ArrayList | LinkedList |
|---------| -------------------- | --------------- |
| 공간적 제약     | - **길이 고정** ⇒ 새로 새로 배열에 새로운 요소를 추가하려고 할 때, 이미 용량이 찼다면 새로운 배열을 생성해주어야 함.<br>- 이 때, 생성된 배열이 메모리 상에 연속으로 생길 수 있지만 이미 다른 값이 메모리를 사용하고 있는 경우, 새로운 위치에 배열이 생성되어야 함.<br>⇒ 모든 요소를 옮김. 또한, 메모리에 여유공간이 없을 경우 에러 발생 가능 | - 한 개의 Node는 다른 Node에 대한 참조만 가지고 있음. 따라서, **공간적 제약을 ArrayList에 비해 받지 않음**| 
| 새로운 요소 추가     | - 여유 공간이 있는 경우 O(1)<br>- 여유 공간이 없는 경우 O(N) | - 항상 O(1)<br>? 마지막 요소에서 다음 참조값을 가지게 하기만 하면 되기 때문 | 
| 접근     | - **Random Access**<br>- 시간복잡도 O(1) | - **Sequential Access**<br>- 시간복잡도 O(N) | 
| 중간에 새로운 요소 삽입     | - 해당 요소 뒤의 요소들도 전부 옮겨야 함 | - 앞 뒤 요소의 값만 바꾸어 주면 됨 | 
| 중간 요소 삭제     | - 뒤의 요소들을 전부 앞으로 이동시켜야 함 | - 앞 뒤 요소의 값만 바꾸어 주면 됨 | 
<br>

**LinkedList vs ArrayList 시간복잡도 정리**
![img](https://media.vlpt.us/images/humblechoi/post/5d8e9aa6-ae4a-4c5a-b627-3ef8e2224afe/image.png)
<br>

Q. *일반적으로 get / set 을 자주 사용한다면?* 
A. **ArrayList**

Q. *일반적으로 처음이나 끝에 잦은 삽입, 삭제가 발생한다면?* 
A. **LinkedList**

> But, 공간 복잡도의 경우 **ArrayList**는 연속된 메모리안에 저장되므로 낭비되는 공간이 없기 때문에 종종 속도가 더 빠른 경우가 발생하기도 함.
> **LinkedList**는 요소마다 두개의 참조 노드가 필요하기 때문에 더 많은 공간을 차지하고, 메모리 여기저기 노드가 흩어져 존재하는 경우 효율이 더욱 떨어질 수 있으니 잘 선택!

<br>

### 상황에 따른 자료구조 선택
**Q. 데이터에 접근할 때 좋은 자료구조는?**
* **Array** : `Random Access`를 지원 ⇒ 특정 요소에 접근하는 시간복잡도는 `O(1)`
* **LinkedList**: `Sequential Access`를 지원 ⇒ 특정 요소에 접근할 때 시간복잡도는 `O(N)`
<br>

**Q. 데이터를 추가하거나 삭제할 때 좋은 자료구조는?**
* **Array** : `인접한 메모리에 연이어 저장` ⇒ 삽입과 삭제의 시간복잡도는 `O(N)`
* **LinkedList**: `새로운 요소에 할당된 메모리의 위치가 이전 요소에 저장` ⇒ 특정 요소에 접근할 때 시간복잡도는 `O(1)`
<br>

**Q. 메모리 할당?**
* **Array** 
	* `정적 메모리 할당` ⇒ 메모리는 선언 시 컴파일 타임에 할당
	* `Stack` 섹션에 메모리 할당
* **LinkedList**
	* `동적 메모리 할당` ⇒ 새로운 요소가 추가될 때 런타임에 메모리 할당
	* `Heap` 섹션에 메모리 할당
<br>

**Q. 데이터를 검색할 때 좋은 자료구조는?**
A. ArrayList가 좋다. 이외에는 Binary Search Tree가 있다.
<br>

**Q. 사이즈를 변경할 때 사용하면 좋은 자료구조는?**
A. list형 자료구조이다.
<br>

---
**참고 자료**
* https://velog.io/@jha0402/Data-structure-%EA%B0%9C%EB%B0%9C%EC%9E%90%EB%9D%BC%EB%A9%B4-%EA%BC%AD-%EC%95%8C%EC%95%84%EC%95%BC-%ED%95%A0-7%EA%B0%80%EC%A7%80-%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0
* https://velog.io/@humblechoi/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-%EB%A9%B4%EC%A0%91%EC%A7%88%EB%AC%B8-%EB%AA%A8%EC%9D%8C
* https://velog.io/@humblechoi/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-Array-vs-ArrayList
