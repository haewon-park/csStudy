# **B-Tree & B+Tree**

## **🥕B-Tree**

![image](https://user-images.githubusercontent.com/63101648/129515925-f0d3c94f-ef15-42b3-a135-8d629a304537.png)

<br>

### **정의**
데이터를 정렬하여 탐색, 삽입, 삭제 및 **순차 접근이 가능하도록 유지하는 트리형 자료구조**

<br>

### **왜 쓰는가?**
- **Balanced Tree의 일종**으로 트리의 균형이 맞다.
- 삽입과 삭제가 일어나더라도 최대한 균형있는 트리 형태를 유지하여 **이진 탐색의 장점을 살린 트리**
- 균형이 맞춰져있기에 이진 탐색을 활용할 수 있다는 장점이 있다. 

✔ 편향 트리는 모든 노드를 하나하나 다 보면서 원하는 키 값을 찾는 검색을 하며 O(n)의 검색 시간을 갖게 된다.(효율 낮음)

✔ 균형이 갖춰진 트리는 O(log n) 시간의 검색 시간을 갖는다.

<br>

### B tree의 특징 
1. 노드의 자료수가 K라면 자식의 수는 K+1개여야함
2. 자료는 정렬된 상태로 저장된다.
3. 한 노드 N의 왼쪽 서브트리는 N의 키 작은 값으로 되어있으며 오른쪽 서브트리는 큰 값으로 되어있다. 
4. 루트 노드는 적어도 2개 이상의 자식을 가져야한다.(트리가 루트 노드로만 구성되어있을 경우 제외)
5. 루트 노드를 제외한 모든 노드는 적어도 [M/2]개의 키를 가지고 있어야한다.
6. 입력 자료는 중복될 수 없다.
7. 리프노드로 가는 경로의 길이는 모두 같다. (리프 노드는 모두 같은 레벨에 있다.)

<br>

### DB Index로 B트리가 가장 적합한 이유
1. 항상 정렬된 상태로 특정 값보다 크고 작은 부등호 연산에 문제가 없다.
2. 참조 포인터가 적어 방대한 데이터 양에도 빠른 메모리 접근이 가능
3. 데이터 탐색 뿐만 아니라 저장, 수정, 삭제에도 항상 O(log n)의 시간복잡도를 가진다. 

<br>

### B트리의 **삽입**
1. 자료는 **항상 리프 노드에 추가**된다.
2. 리프 노드의 선택은 루트 노드부터 시작해서 **하향식으로 탐색하며 결정**한다.
3. **선택한 리프 노드에 여유가 있다면 그냥 삽입하고 없다면 분할**한다.

<br>

### B트리의 **삭제**
1. 삭제하려는 키 값을 가진 노드가 가지고 있는 키 개수를 해당 키 값 삭제 후에 M/2개 이상이 되도록 해야한다.
2. **형제한테 빌리기, 형제와 결합하기**
3. 삭제 키가 있는 노드가 내부 노드인 경우 대체 키를 찾아 대체한다.

<br>

### B트리의 시간 복잡도

![O](https://user-images.githubusercontent.com/63101648/129514200-82693f83-c235-4f61-9a7e-1127a9ec1be3.PNG)

<br>

## **🥕B+Tree**

![b+](https://user-images.githubusercontent.com/63101648/129307396-3a379059-c0fe-42c7-849a-b740b4700d9e.png)

- B+-Tree는 B-Tree의 확장개념
- 브랜치 노드에 **key만 담아두고 data는 담지 않는다.** 
- **리프 노드에만 key와 data를 저장**하고 **리프 노드끼리 Linked list로 연결**되어 있다.

<br>


### B+Tree 삽입

![b_plus_tree_6](https://user-images.githubusercontent.com/63101648/129515281-12af1589-53dc-4ae2-ae78-55b1726ba578.png)

- B트리의 리프 노드에 삽입하는 것과 유사
- 차이점이라면 리프 노드 분할 시 중간 키 값의 복사본이 부모 인덱스 노드로 올라간다.

<br> 

### B+Tree 삭제

![b_plus_tree_7](https://user-images.githubusercontent.com/63101648/129515325-6c32c329-effd-44f2-a0fd-5de63c11f88b.png)

- B트리와 유사
- 차이점
  - **키 값의 삭제는 리프 노드에서만** 수행
  - 인덱스 세트의 키 값을 삭제할 필요할 있는 경우에는 삭제하지 않고 분리자로 이용

<br> 

### B+Tree의 장점
- 리프 노드를 제외하고 데이터를 담아두지 않기 때문에 메모리를 더 확보함으로써 더 많은 키들을 수용할 수 있음
- 하나의 노드에 더 많은 키들을 담을 수 있어 트리의 높이는 더 낮아짐
- B-Tree는 모든 노드를 확인해야하지만 B+-Tree는 리프 노드에 데이터가 모두 존재하기에 한번의 선형 탐색만 이뤄지므로 더 빠름 

<br>

## **B-tree Vs B+tree** 
| 구분 | B-tree | B+-tree |
|:--------|:--------:|--------:|
| 데이터 저장 | 리프노드, 브랜치 노드 모두 데이터 저장 가능 | 오직 리프 노드에만 데이터 저장 가능 |
| 트리의 높이 | 높음 | 낮음 |
| 풀스캔시 검색 속도 | 모든 노드 탐색 | 리프 노드에서만 선형 탐색 |
| 키 중복 | 없음 | 있음(리프 노드에 모든 데이터가 있기 때문) |
| 검색 | 자주 접근되는 노드를 루트 노드 가까이 배치할 수 있고 루트 노드에서 가까울 경우, 브랜치 노드에도 데이터가 존재하기 때문에 빠름 | 리프 노드까지 가야 데이터 존재 |
| 링크드 리스트 | 없음 | 리프노드끼리 링크드리스트로 연결 |

<br>

### 🥕궁금한 사람은 한번 만들어보세요(B트리)
https://www.cs.usfca.edu/~galles/visualization/BTree.html

<br>

### 출처
- https://zorba91.tistory.com/293
- https://matice.tistory.com/8
- https://velog.io/@syeeuns/B-tree-%EA%B2%80%EC%83%89-%EC%82%BD%EC%9E%85-%EC%82%AD%EC%A0%9C
- https://velog.io/@jun7867/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-%EB%A9%B4%EC%A0%91-%EC%A4%80%EB%B9%84
- https://goodgid.github.io/FP-B+-Tree/
- https://www.programiz.com/dsa/b-tree
- https://www.programiz.com/dsa/insertion-into-a-b-tree (B트리 삽입 예시)
- https://www.programiz.com/dsa/deletion-from-a-b-tree (B트리 삭제 예시)
