## 트랜잭션(Transaction)
### 1. 트랜잭션(Transaction) 이란? 
**💡 정의** 
> DBMS에서 데이터를 다루는 논리적인 작업의 단위
> 쪼개질 수 없는 업무 처리의 단위
<br>

**연산**
* 커밋(Commit): 모든 부분작업이 정상적으로 완료하면 이 변경사항을 한꺼번에 DB에 반영한다.
* 롤백(Rollback): 부분 작업이 실패하면 트랜잭션 실행 전으로 되돌린다.
<br>

**상태**
![img](https://gmlwjd9405.github.io/images/basic-concepts-of-development/transaction-status.png)
* **활동(Active)**: 트랜잭션이 실행 중에 있는 상태, 연산들이 정상적으로 실행 중인 상태
* **장애(Failed)**: 트랜잭션이 실행에 오류가 발생하여 중단된 상태
* **철회(Aborted)**: 트랜잭션이 비정상적으로 종료되어 Rollback 연산을 수행한 상태
* **부분 완료(Partially Committed)**: 트랜잭션이 마지막 연산까지 실행했지만, Commit 연산이 실행되기 직전의 상태
* **완료(Committed)**: 트랜잭션이 성공적으로 종료되어 Commit 연산을 실행한 후의 상태
<br>

**필요성** 
* 트랜 잭션의 `ACID`를 제공받기 위해 트랜잭션을 사용!

##

### 💡 2. 트랜잭션의 4가지 성질 ACID 
* `원자성(Atomicity)`: 한 트랜잭션 내에서 실행한 작업들은 하나의 작업으로 간주한다. 모두 성공 또는 모두 실패되어야 한다.  
* `일관성(Consistency)`: 모든 트랜잭션은 일관성 있는 데이타베이스 상태를 유지한다. 이를테면 DB에서 정한 무결성 조건을 항상 만족.  
* `독립성(Isolation)`: 동시에 실행되는 트랜잭션들이 서로 영향을 미치지 않도록 격리 해야한다.  
* `영속성(Durability)`: 트랜잭션을 성공적으로 마치면 그 결과가 항상 저장되어야 한다.  
<br>

*이 중 격리성(Isolation)에 대한 이슈가 있다.*

> 격리성을 완벽히 보장하기 위해 모든 트랜잭션을 순차적으로 실행한다면 동시성 처리 이슈가 발생한다. 반대로 동시성을 높이기 위해 여러 트랜잭션을 병렬처리하게 되면 데이터의 무결성이 깨질 수 있다.  

##

### 3. 로킹 제어 기법
**트랜잭션 병행 처리 시 발생하는 문제점**
* **갱신 내용 손실**: 동시에 하나의 데이터를 갱신될 때 하나의 갱신이 누락된 경우
* **현황 파악 오류**: 하나의 데이터 갱신이 끝나지 않은 시점에서 다른 트랜잭션이 해당 데이터를 조회하는 경우
* **모순성**: 두 트랜잭션이 동시에 실행될 때 데이터베이스가 일관성 없는 모순된 상태로 남는 문제  
* **연쇄 복귀**: 두 트랜잭션이 하나의 레코드를 갱신할 때 하나의 트랜잭션이 롤백 했을 경우 다른 하나의 트랜잭션 마저도 롤백 되는 문제
<br>

*따라서, 트랜잭션 병행 처리 방지를 위해 로킹 제어 기법을 사용한다*

**로킹 제어 기법이란?**
> 로킹 이란 어떤 트랜잭션이 DB의 데이터를 사용할 떄 DB의 일정부분을 Lock 시키고 트랜잭션이 완료될 때 해당 부분을 Unlock 시키는 방법이다. 종류는 크게 두가지로 공유 로킹은 Lock 한 부분은 읽을 수는 있지만 쓰기는 불가능하며, 배타 로킹은 읽기,쓰기 둘 다 불가능 하게 한 것

**Lock의 종류**
* **Shared Lock(Read Lock)** : 데이터를 읽을 때 사용하는 Lock, 같은 Read Lock 끼리는 동시에 접근 가능 ! 
⇒ 사용자가 데이터를 읽어갈 뿐, 데이터 변경이 없기 때문에 가능 !
⇒ 그러나, Exclusive Lock의 접근은 막음 !
* **Exclusive Lock(Write Lock)**: 데이터를 변경할 때 사용하는 Lock
⇒ 트랜잭션이 완료될 때까지 유지되며 어떠한 접근도 허용하지 않음!

**로킹 제어가 일으킬 수 있는 문제점**
* 로킹 단위에 따라 다르지만 트랜잭션의 직렬화 가능성이 높아진다.
* 데드락이 발생할 수 있다.

**로킹 단위에 따른 차이점**
* 로킹 단위가 크면 그만큼 관리가 쉽지만 병행성이 떨어진다.
* 로킹 단위가 작으면 관리가 어렵고, 오버헤드가 증가하지만 병행성이 올라간다.

---

**참고 자료**
* https://yubh1017.tistory.com/56
* https://jun7343.github.io/2020/11/28/database-interview.html
* https://mangkyu.tistory.com/30?category=761304

