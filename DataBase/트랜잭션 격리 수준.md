## 트랜잭션 격리 수준(Transaction Isolation Level)
### 1. 트랜잭션 격리수준(isolation Level)
**정의**
> 동시에 여러 트랜잭션이 처리될 때, 트랜잭션끼리 얼마나 서로 고립되어 있는지를 나타내는 것.
> 즉, 특정 트랜잭션이 다른 트랜잭션에 변경한 데이터를 볼 수 있도록 허용할지 말지를 결정하는 것.
<br>

**필요성**
* 무조건적인 Locking으로 동시에 수행되는 많은 트랜잭션들을 순서대로 처리하는 방식으로 구현되면 DB의 성능은 떨어짐 !
* 반대로 응답성을 높이기 위해 Locking 범위를 줄인다면 잘못된 값이 처리 될 수 있음 !
* 그래서 최대한 효율적인 Locking 방법이 필요 !

##

### 2. 낮은 단계의 트랜잭션 격리 수준을 이용할 시 발생하는 현상
1. `Dirty Read` : 커밋되지 않은 수정중인 데이터를 다른 트랜잭션에서 읽을 수 있도록 허용할 때 발생하는 현상
⇒ 어떤 트랜잭션에서 아직 실행이 끝나지 않은 다른 트랜잭션에 의한 변경사항을 보게되는 경우
<br>

2. `Non-Repeatable Read`: 한 트랜잭션에서 같은 쿼리를 두 번 수행할 때 그 사이에 다른 트랜잭션 값을 수정 또는 삭제하면서 두 쿼리의 결과가 상이하게 나타나는 일관성이 깨진 현상
<br>

3. `Phantom Read` : 한 트랜잭션 안에서 일정 범위의 레코드를 두 번 이상 읽었을 때, 첫번째 쿼리에서 없던 레코드가 두번째 쿼리에서 나타나는 현상
⇒ 트랜잭션 도중 새로운 레코드 삽입을 허용하기 때문에 나타나는 현상임

##

### 3. 트랜잭션 격리 수준의 종류
_위의 문제들 때문에 트랜잭션의 격리성과 동시 처리 성능 사이의  **Trade-off**를 두고 4단계 격리수준을 나누었음 !_

1. Read uncommitted(Level 0)
	> 한 트랜잭션에서 커밋하지 않은 데이터에 다른 트랜잭션이 접근 가능
	> 즉 커밋하지 않은 데이터를 읽을 수 있음 !
	* 발생 문제점: `Dirty Read`, `Non-Repeatable Read`, `Phantom Read`
	* 데이터베이스의 일관성 유지 불가능 !
	* 대신, 동시 처리 성능은 가장 높음 !
  <br>
  
2. Read Committed(Level 1)
	> 커밋이 완료된 데이터만 읽기 가능 !
	* 발생 문제점: `Non-Repeatable Read`, `Phantom Read`  
	* Read uncommitted 수준보다 동시 처리 성능은 떨어짐.
	* SQL 서버가 디폴트로 사용하는 레벨
	<br>
	
3. Repeatable Read(Level 2)
	> 트랜잭션 내에서 한번 조회한 데이터를 반복해서 조회해도 같은 데이터가 조회된다.
	* 발생 문제점: `Phantom Read`
	* 트랜잭션이 범위 내에서 조회한 데이터의 내용이 항상 동일함을 보장함.
<br>

4. Serializable(Level 3)
	> 가장 엄격한 격리수준
	* 3가지 문제점 모두 커버 가능
	* 동시 처리 성능은 급격히 떨어질 수 있음.
	*  완벽한 읽기 일관성 모드를 제공함.
<br>

_**선택 시 고려사항**_
* 동시성을 증가시키면 데이터 무결성에 문제가 발생하고, 데이터 무결성을 유지하면 동시성이 떨어지게 됨
* 레벨을 높게 조정할 수록 발생하는 비용이 증가함

---

**참고 자료**
* https://feco.tistory.com/45
* https://doooyeon.github.io/2018/09/29/transaction-isolation-level.html
