# Merge Sort

<br>

## Merge Sort 개념 
`배열을 앞부분과 뒷부분으로 나누어 각각 정렬한 다음 합병하는 작업을 반복하여 정렬`
**안정 정렬**에 속하며, **분할 정복 알고리즘**의 하나이다.

<br>

### **Divide and Conquer**
**1. 분할** : 정렬되지 않은 배열을 **절반으로 잘라 비슷한 크기의 두 배열**로 나눔

**2. 정복** : 각 부분 배열을 **재귀적으로 합병 정렬**을 이용하여 정렬 

**3. 결합** : **두 부분 배열을 다시 하나의 정렬된 배열**로 합병
    - 정렬 결과는 입시 배열에 저장됨 

**4. 복사** : 임시 배열에 저장된 결과를 **원래 배열에 복사** 

<br>

![merge-sort-concepts](https://user-images.githubusercontent.com/63101648/132125565-724f9898-9562-435f-95a1-8902b80ca6ce.png)

- 2개의 정렬된 리스트로 만들기
- 2개의 리스트를 하나씩 비교하여 더 작은 값을 새로운 리스트로 옮김
- 둘 중 하나가 끝날때까지 과정 반복
- 만약 하나의 리스트가 먼저 끝나게 도면 나머지 리스트의 값들을 전부 새로운 리스트로 복사
- 새로운 리스트를 원래의 리스트로 옮김 
 
<br>


## **Merge Sort 특징**
### **장점**
- 시간 복잡도
    - 배열의 요소가 1개가 될 때까지 분할 -> n번 호출
    - 배열을 반씩 분할해가며 정렬 -> logN만큼의 시간 소요
    - 최종적으로 한 번 호출 당 검색할 데이터 양이 절반이므로 O(nlogn)의 시간복잡도를 가짐 
- 안정적인 정렬 
    - 입력 데이터가 무엇이든 **정렬되는 시간은 동일**( =O(nlogn) )
- 레코드를 **연결 리스트로 구성**하면, **링크 인덱스만 변경되므로 데이터의 이동은 무시할 수 있을 정도로 작아짐**
    - 제자리 정렬로 구현 가능
- 크기가 큰 레코드를 정렬할 때 **연결 리스트를 사용한다면** 합병 정렬은 퀵 정렬을 포함한 다른 정렬 방법보다 **효율적임**

### **단점**
- 만약 레코드를 **배열로 구성**하면 **임시 배열이 필요**
    - 제자리 정렬로 구현 불가
- **레코드의 크기가 크면 이동 횟수가 많아** 매우 큰 시간적 낭비 발생

<br>

### **안정 정렬**
동일한 값에 대해 기존의 순서가 유지되는 정렬 방식
### **제자리 정렬**
주어진 공간 외에 추가적인 공간을 사용하지 않는 정렬 

<br>

### 출처
- https://gmlwjd9405.github.io/2018/05/08/algorithm-merge-sort.html
- https://velog.io/@roro/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%ED%95%A9%EB%B3%91%EB%B3%91%ED%95%A9%EC%A0%95%EB%A0%AC
