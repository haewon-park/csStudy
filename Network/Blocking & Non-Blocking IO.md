## Blocking & Non-Blocking I/O

### I/O 작업
I/O 작업은 User level에서 직접 수행할 수 없고, Kernel level에서만 수행할 수 있다.

따라서, **유저 프로세스(스레드)는 커널에게 I/O 작업을 요청하고 작업 완료 후 커널이 반환하는 결과를 기다릴 뿐이다.**

네트워크에서의 I/O 작업은 소켓의 read/send를 생각하자.


### 1. Blocking I/O
> I/O 작업이 진행되는 동안 유저 프로세스는 자신의 작업을 중단한 채 대기하는 방식

![](https://user-images.githubusercontent.com/41428527/51266321-4ade9700-19fe-11e9-9b23-30bca4faccfd.png)

**진행 순서**

1. 유저가 커널에게 read 작업 요청
2. 데이터가 입력될 때까지 대기
3. 데이터가 입력되면 커널 모드에서 유저모드로 데이터 복사

**특징**
- I/O 작업이 진행되는 동안 유저 프로세스는 **자신의 작업을 중단한 채 대기**
- 어플리케이션에서 다른 작업을 수행하지 못하고 대기하므로 **자원 낭비** 
    
<br>

### 2. Non-Blocking I/O
> I/O 작업이 진행되는 동안 유저 프로세스의 작업을 중단시키지 않는 방식

![](https://user-images.githubusercontent.com/41428527/51266324-4e721e00-19fe-11e9-900a-809ff39e40c1.png)

**진행 순서**

1. 유저가 커널에게 read 작업 요청
2. 요청하는 그 순간, 바로 결과 반환
	입력 데이터가 없으면 입력 데이터가 없다는 결과 메시지(EWOULDBLOCK) 반환
3. 입력 데이터가 있을 때 까지 1-2번 반복
4. 입력 데이터가 있으면 커널 모드에서 유저모드로 데이터 복사

**특징**
- I/O 진행시간과 관계가 없기 때문에 어플리케이션에서 **작업을 중지하지 않고도 I/O 작업을 진행 가능**
- 반복적으로 시스템 호출이 발생하기 때문에 **자원 낭비**

<br>

#### 참고 링크
https://ju3un.github.io/network-basic-1/
