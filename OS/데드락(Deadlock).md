# 데드락 (Deadlock)

## **정의**
 - 프로세스가 자원을 얻지 못해 다음 처리를 하지 못하는 상태
- 서로 원하는 자원을 얻기 위해 **무한정한 기다림 상태**에 빠지는 것 
- 멀티 프로그래밍 환경에서 **한정된 자원을 사용하려고 서로 경쟁**하는 상황 발생 
- 데드락 = **교착 상태**

![deadlock](https://user-images.githubusercontent.com/63101648/126871084-88375fe7-c948-4392-ad86-eb8970303f02.png)


<br>
  
## **발생 조건** 
‼4가지 조건이 동시에 성립해야 함‼

⭐ **상호배제 (Mutual Exclusion)**

자원은 한 번에 한 프로세스만 사용이 가능

⭐ **점유와 대기 (Hold and Wait)**

최소한 하나의 자원을 점유하고 있으면서 다른 프로세스에 할당되어 사용하고 있는 자원을 추가로 점유하기 위해 대기하는 프로세스가 있어야 함

⭐ **비선점 (Non Preemptive)**

다른 프로세스에 할당된 자원은 **사용이 끝날 때까지 강제로 빼앗을 수 없음** 

⭐ **순환 대기 (Circular wait)**

프로세스의 집합 {p0, p1, ... , pn}이 있을 때, p0은 p1이 점유한 자원을 대기하고 p1은 p2가 점유한 자원을 대기하고 pn은 p0이 점유한 자원을 요구해야 함  

<br>

## **솔루션**
### ⭐ **교착 상태 예방**

`교착 상태가 발생하기 전에 미리 조치를 취하는 방식`
- **자원의 상호배제 조건 방지**

  - 모든 자원을 공유 허용 
- **점유와 대기 조건 방지**
  - 모든 자원에 대해 선점 허용
- **비선점 조건 방지**
  - 필요 자원을 한 번에 모두 할당하기
- **순환 대기 조건 방지**
  - 자원에게 순서 부여를 통해 프로세스 순서의 증가 방향으로만 자원 요청 
 
### ⭐ **교착 상태 회피**
`데드락이 발생할 위험이 있는 자원이 생기면 자원 할당 요청을 보류하여 시스템을 안전하게 유지하는 방법`
- 오버헤드가 많이 발생한다.
- **Banker's Algorithm**

프로세스가 자원을 요구할 때 시스템은 자원을 할당한 후에도 안정 상태로 남아있는가를 확인하여 교착 상태를 회피하는 방법
안정 상태에 있으면 자원을 할당, 불안정상태에 있으면 다른 프로세스들이 자원을 해지할 때까지 기다린다. 


### ⭐ **교착 상태 탐지**
`데드락이 발생하면 이를 빠르게 발견하고 문제를 해결하는 것`

![graph](https://user-images.githubusercontent.com/63101648/126871724-4547e5c8-571c-4151-8b44-ed6c1b9c89f4.jpeg)


- 자원 할당 그래프(Resource Allocation Graph)를 통해 교착 상태 탐지 가능


### ⭐ **교착 상태 회복**

`교착 상태를 일으킨 프로세스를 종료하거나 할당된 자원을 해제하면서 회복`

**1. 프로세스 종료 방법**
- 교착 상태의 프로세스 모두 중지
- 교착 상태가 제거될 때까지 한 프로세스씩 중지

**2. 자원 선점 방법**
- 자원을 빼앗긴 프로세스는 강제 종류 이후 재시작
- 교착 상태에 빠진 프로세스가 필요로 하는 자원을 강제로 가져옴 

<br>

### 출처
 - https://velog.io/@woga1999/%EB%8D%B0%EB%93%9C%EB%9D%BD%EA%B3%BC-Starvation
 - https://prinha.tistory.com/entry/%EB%8D%B0%EB%93%9C%EB%9D%BD
 - https://junco.tistory.com/120
