## 메인 메모리
> CPU가 직접 접근할 수 있는 기억 장치

- 프로세스가 실행되려면 프로그램이 메모리에 올라와야 한다.
- 주소가 할당된 일련의 바이트들로 구성되어 있다.

<br>

## 메모리 관리 장치 (MMU: Memory Management Unit)
> 메모리 보호나 캐시 관리 등 CPU가 메모리에 접근하는 것을 총 관리해주는 하드웨어<br>
> 가상 메모리 주소 -> 실제 메모리 주소로 변환 

![](https://images.velog.io/images/hammii/post/95a4fd39-e9c8-411b-b31f-01c1d384cb8e/image.png)

<br>

### MMU의 메모리 보호
프로세스는 독립적인 메모리 공간을 가져야 되고, 자신의 공간만 접근해야 한다.<br>
따라서 한 프로세스에게 합법적인 주소 영역을 설정하고, 잘못된 접근이 오면 trap을 발생시키며 보호한다.

![](https://images.velog.io/images/hammii/post/94400588-c71f-4e81-89b9-2e231b9c04dd/image.png)

`base`와 `limit` 레지스터를 활용한 메모리 보호 기법이다.
- `base` 레지스터: 시작 physical 주소
- `limit` 레지스터: 크기

```
base <= x < base + limit
```
프로세스의 접근 가능한 메모리 영역(x) 밖에서 접근을 요구하면 trap을 발생시킴으로써 메모리를 보호한다.

💡 안전성을 위해 base와 limit 레지스터는 커널 모드에서만 수정 가능하도록 설계한다.

<br>

### 메모리 과할당
> 실제 메모리의 사이즈보다 더 큰 사이즈의 메모리를 프로세스에 할당한 상황

이러한 과할당을 해결하기 위해선, 빈 프레임을 확보할 수 있어야 한다.

1. 메모리에 올라와 있는 한 프로세스를 종료시켜 빈 프레임을 얻음
2. 프로세스 하나를 swap out하고, 이 공간을 빈 프레임으로 활용

1번은 사용자에게 페이징 시스템을 들킬 가능성이 매우 높아서 하면 안 된다.
따라서, **2번과 같은 해결책을 통해 [페이지 교체](https://github.com/haewon-park/csStudy/blob/main/OS/%EA%B0%80%EC%83%81%EB%A9%94%EB%AA%A8%EB%A6%AC%20%26%20%ED%8E%98%EC%9D%B4%EC%A7%80%20%EA%B5%90%EC%B2%B4%20%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98.md)가 이루어져야 한다.**

<br>

## 캐시 메모리
> 주기억장치에 저장된 내용의 일부를 임시로 저장해두는 기억 장치

- CPU와 주기억장치의 속도 차이로 성능 저하를 방지하기 위한 방법
- CPU가 이미 봤던걸 다시 재접근할 때, 메모리 참조 및 인출 과정에 대한 비용을 줄이기 위해 캐시에 저장해둔 데이터를 활용한다.
- 캐시는 플리플롭 소자로 구성되어 SRAM으로 되어있어서 DRAM보다 빠른 장점을 지닌다.

`Hit`: 캐시 기억장치에 명령이 존재
(CPU에서 주소 전달 -> 캐시 기억장치 확인 -> 해당 명령어 CPU로 전송)

`Miss`: 캐시 기억장치에 명령이 존재하지 않음
(CPU에서 주소 전달 -> 캐시 기억장치 확인 -> 주기억장치로 접근 -> 해당 명령어를 가진 데이터 인출 -> 데이터를 캐시에 저장 -> 해당 명령어 CPU로 전송)

따라서 CPU가 어떤 데이터를 원할지 어느정도 예측할 수 있어야 함 !!
이러한 예측 적중률을 높이기 위해 사용하는 것이 바로 지역성의 원리

<br>

### 지역성
> 기억 장치 내의 정보를 균일하게 액세스 하는 것이 아니라 한 순간에 특정 부분을 집중적으로 참조하는 특성

- 시간 지역성 : 최근에 참조된 주소의 내용은 곧 다음에도 참조되는 특성
- 공간 지역성 : 실제 프로그램이 참조된 주소와 인접한 주소의 내용이 다시 참조되는 특성

<br>

### 캐싱 라인
> 캐시에 데이터를 저장할 시, 자료구조를 활용해 묶어서 저장하는 것

- 필요한 데이터를 캐시에서 찾을 때 모든 데이터를 순회하는 것은 시간 낭비
- 캐시에 저장하는 데이터에 데이터의 메모리 주소를 함께 저장하면서 빠르게 원하는 정보를 찾을 수 있다. (set, map 등을 활용)

<br>

#### 참고 링크
https://ko.wikipedia.org/wiki/%EB%A9%94%EB%AA%A8%EB%A6%AC_%EA%B4%80%EB%A6%AC_%EC%9E%A5%EC%B9%98

https://gyoogle.dev/blog/computer-science/operating-system/Memory.html#%E1%84%8F%E1%85%A2%E1%84%89%E1%85%B5%E1%86%BC-%E1%84%85%E1%85%A1%E1%84%8B%E1%85%B5%E1%86%AB
